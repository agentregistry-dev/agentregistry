// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: `${string}://${string}` | (string & {});
};

export type AgentJson = {
    description: string;
    framework: string;
    image: string;
    language: string;
    mcpServers?: Array<McpServerType>;
    modelName: string;
    modelProvider: string;
    name: string;
    packages?: Array<AgentPackageInfo>;
    remotes?: Array<Transport>;
    /**
     * Optional repository metadata for the agent source code.
     */
    repository?: Repository;
    skills?: Array<SkillRef>;
    status?: string;
    telemetryEndpoint?: string;
    title?: string;
    updatedAt?: string;
    version: string;
    websiteUrl?: string;
};

export type AgentListResponse = {
    agents: Array<AgentResponse>;
    metadata: AgentMetadata;
};

export type AgentMetadata = {
    count: number;
    nextCursor?: string;
};

export type AgentPackageInfo = {
    identifier: string;
    registryType: string;
    transport: AgentPackageInfoTransportStruct;
    version: string;
};

export type AgentPackageInfoTransportStruct = {
    type: string;
};

export type AgentRegistryExtensions = {
    isLatest: boolean;
    publishedAt: string;
    status: string;
    updatedAt: string;
};

export type AgentResponse = {
    _meta: AgentResponseMeta;
    agent: AgentJson;
};

export type AgentResponseMeta = {
    'aregistry.ai/deployments'?: ResourceDeploymentsMeta;
    'aregistry.ai/semantic'?: AgentSemanticMeta;
    'io.modelcontextprotocol.registry/official'?: AgentRegistryExtensions;
};

export type AgentSemanticMeta = {
    score: number;
};

export type Argument = {
    /**
     * A list of possible values for the input. If provided, the user must select one of these values.
     */
    choices?: Array<string>;
    /**
     * The default value for the input. This should be a valid value for the input. If you want to provide input examples or guidance, use the placeholder field instead.
     */
    default?: string;
    /**
     * A description of the input, which clients can use to provide context to the user.
     */
    description?: string;
    /**
     * Specifies the input format. Supported values include filepath, which should be interpreted as a file on the user's filesystem.
     */
    format?: 'string' | 'number' | 'boolean' | 'filepath';
    /**
     * Whether the argument can be repeated multiple times.
     */
    isRepeated?: boolean;
    /**
     * Whether the input is required
     */
    isRequired?: boolean;
    /**
     * Indicates whether the input is a secret value (e.g., password, token). If true, clients should handle the value securely.
     */
    isSecret?: boolean;
    /**
     * The flag name (for named arguments), including any leading dashes. Empty for positional arguments.
     */
    name?: string;
    /**
     * A placeholder for the input to be displaying during configuration. This is used to provide examples or guidance about the expected form or content of the input.
     */
    placeholder?: string;
    /**
     * Argument type: 'positional' or 'named'
     */
    type: string;
    /**
     * The value for the input. If this is not set, the user may be prompted to provide a value. Identifiers wrapped in {curly_braces} will be replaced with the corresponding properties from the input variables map.
     */
    value?: string;
    /**
     * An identifier for positional arguments. Used in transport URL variable substitution.
     */
    valueHint?: string;
    /**
     * A map of variable names to their values. Keys in the input value that are wrapped in {curly_braces} will be replaced with the corresponding variable values.
     */
    variables?: {
        [key: string]: Input;
    };
};

export type CreateProviderInput = {
    config?: {
        [key: string]: unknown;
    };
    id?: string;
    name: string;
    platform: string;
};

export type Deployment = {
    deployedAt: string;
    env: {
        [key: string]: string;
    };
    error?: string;
    id: string;
    origin: string;
    preferRemote: boolean;
    providerConfig?: {
        [key: string]: unknown;
    };
    providerId?: string;
    providerMetadata?: {
        [key: string]: unknown;
    };
    resourceType: string;
    serverName: string;
    status: string;
    updatedAt: string;
    version: string;
};

export type DeploymentRequest = {
    /**
     * Deployment environment variables.
     */
    env?: {
        [key: string]: string;
    };
    /**
     * Prefer remote deployment over local
     */
    preferRemote?: boolean;
    /**
     * Optional provider-specific deployment settings (not env vars).
     */
    providerConfig?: {
        [key: string]: unknown;
    };
    /**
     * Concrete provider instance ID. Defaults to local singleton when omitted.
     */
    providerId?: string;
    /**
     * Type of resource to deploy (mcp, agent)
     */
    resourceType?: 'mcp' | 'agent';
    /**
     * Server name to deploy
     */
    serverName: string;
    /**
     * Version to deploy (use 'latest' for latest version)
     */
    version: string;
};

export type DeploymentSummary = {
    deployedAt: string;
    id: string;
    origin: string;
    providerId?: string;
    status: string;
    updatedAt: string;
    version?: string;
};

export type DeploymentsListResponseBody = {
    /**
     * List of deployed servers
     */
    deployments: Array<Deployment>;
};

export type EmptyResponse = {
    /**
     * Success message
     */
    message: string;
};

export type ErrorDetail = {
    /**
     * Where the error occurred, e.g. 'body.items[3].tags' or 'path.thing-id'
     */
    location?: string;
    /**
     * Error message text
     */
    message?: string;
    /**
     * The value at the given location
     */
    value?: unknown;
};

export type ErrorModel = {
    /**
     * A human-readable explanation specific to this occurrence of the problem.
     */
    detail?: string;
    /**
     * Optional list of individual error details
     */
    errors?: Array<ErrorDetail>;
    /**
     * A URI reference that identifies the specific occurrence of the problem.
     */
    instance?: string;
    /**
     * HTTP status code
     */
    status?: number;
    /**
     * A short, human-readable summary of the problem type. This value should not change between occurrences of the error.
     */
    title?: string;
    /**
     * A URI reference to human-readable documentation for the error.
     */
    type?: string;
};

export type GitHubOidcTokenExchangeInputBody = {
    /**
     * GitHub Actions OIDC token
     */
    oidc_token: string;
};

export type GitHubTokenExchangeInputBody = {
    /**
     * GitHub OAuth token
     */
    github_token: string;
};

export type HealthBody = {
    /**
     * GitHub OAuth App Client ID
     */
    github_client_id?: string;
    /**
     * Health status
     */
    status: string;
};

export type Icon = {
    /**
     * Optional MIME type override if the source MIME type is missing or generic. Must be one of: image/png, image/jpeg, image/jpg, image/svg+xml, image/webp.
     */
    mimeType?: 'image/png' | 'image/jpeg' | 'image/jpg' | 'image/svg+xml' | 'image/webp';
    /**
     * Optional array of strings that specify sizes at which the icon can be used. Each string should be in WxH format (e.g., '48x48', '96x96') or 'any' for scalable formats like SVG. If not provided, the client should assume that the icon can be used at any size.
     */
    sizes?: Array<string>;
    /**
     * A standard URI pointing to an icon resource. Must be an HTTPS URL. Consumers SHOULD take steps to ensure URLs serving icons are from the same domain as the server or a trusted domain. Consumers SHOULD take appropriate precautions when consuming SVGs as they can contain executable JavaScript.
     */
    src: string;
    /**
     * Optional specifier for the theme this icon is designed for. 'light' indicates the icon is designed to be used with a light background, and 'dark' indicates the icon is designed to be used with a dark background. If not provided, the client should assume the icon can be used with any theme.
     */
    theme?: 'light' | 'dark';
};

export type Input = {
    /**
     * A list of possible values for the input. If provided, the user must select one of these values.
     */
    choices?: Array<string>;
    /**
     * The default value for the input. This should be a valid value for the input. If you want to provide input examples or guidance, use the placeholder field instead.
     */
    default?: string;
    /**
     * A description of the input, which clients can use to provide context to the user.
     */
    description?: string;
    /**
     * Specifies the input format. Supported values include filepath, which should be interpreted as a file on the user's filesystem.
     */
    format?: 'string' | 'number' | 'boolean' | 'filepath';
    /**
     * Whether the input is required
     */
    isRequired?: boolean;
    /**
     * Indicates whether the input is a secret value (e.g., password, token). If true, clients should handle the value securely.
     */
    isSecret?: boolean;
    /**
     * A placeholder for the input to be displaying during configuration. This is used to provide examples or guidance about the expected form or content of the input.
     */
    placeholder?: string;
    /**
     * The value for the input. If this is not set, the user may be prompted to provide a value. Identifiers wrapped in {curly_braces} will be replaced with the corresponding properties from the input variables map.
     */
    value?: string;
};

export type KeyValueInput = {
    /**
     * A list of possible values for the input. If provided, the user must select one of these values.
     */
    choices?: Array<string>;
    /**
     * The default value for the input. This should be a valid value for the input. If you want to provide input examples or guidance, use the placeholder field instead.
     */
    default?: string;
    /**
     * A description of the input, which clients can use to provide context to the user.
     */
    description?: string;
    /**
     * Specifies the input format. Supported values include filepath, which should be interpreted as a file on the user's filesystem.
     */
    format?: 'string' | 'number' | 'boolean' | 'filepath';
    /**
     * Whether the input is required
     */
    isRequired?: boolean;
    /**
     * Indicates whether the input is a secret value (e.g., password, token). If true, clients should handle the value securely.
     */
    isSecret?: boolean;
    /**
     * Name of the header or environment variable.
     */
    name: string;
    /**
     * A placeholder for the input to be displaying during configuration. This is used to provide examples or guidance about the expected form or content of the input.
     */
    placeholder?: string;
    /**
     * The value for the input. If this is not set, the user may be prompted to provide a value. Identifiers wrapped in {curly_braces} will be replaced with the corresponding properties from the input variables map.
     */
    value?: string;
    /**
     * A map of variable names to their values. Keys in the input value that are wrapped in {curly_braces} will be replaced with the corresponding variable values.
     */
    variables?: {
        [key: string]: Input;
    };
};

export type McpServerType = {
    args?: Array<string>;
    build?: string;
    command?: string;
    env?: Array<string>;
    headers?: {
        [key: string]: string;
    };
    image?: string;
    name: string;
    registryServerName?: string;
    registryServerPreferRemote?: boolean;
    registryServerVersion?: string;
    registryURL?: string;
    type: string;
    url?: string;
};

export type Package = {
    /**
     * A mapping of environment variables to be set when running the package.
     */
    environmentVariables?: Array<KeyValueInput>;
    /**
     * SHA-256 hash of the package file for integrity verification. Required for MCPB packages and optional for other package types. Authors are responsible for generating correct SHA-256 hashes when creating server.json. If present, MCP clients must validate the downloaded file matches the hash before running packages to ensure file integrity.
     */
    fileSha256?: string;
    /**
     * Package identifier - either a package name (for registries) or URL (for direct downloads)
     */
    identifier: string;
    /**
     * A list of arguments to be passed to the package's binary.
     */
    packageArguments?: Array<Argument>;
    /**
     * Base URL of the package registry
     */
    registryBaseUrl?: string;
    /**
     * Registry type indicating how to download packages (e.g., 'npm', 'pypi', 'oci', 'nuget', 'mcpb')
     */
    registryType: string;
    /**
     * A list of arguments to be passed to the package's runtime command (such as docker or npx). The runtimeHint field should be provided when runtimeArguments are present.
     */
    runtimeArguments?: Array<Argument>;
    /**
     * A hint to help clients determine the appropriate runtime for the package. This field should be provided when runtimeArguments are present.
     */
    runtimeHint?: string;
    /**
     * Transport protocol configuration for the package
     */
    transport: Transport;
    /**
     * Package version. Must be a specific version. Version ranges are rejected (e.g., '^1.2.3', '~1.2.3', '>=1.2.3', '1.x', '1.*').
     */
    version?: string;
};

export type PingBody = {
    /**
     * Ping response
     */
    pong: boolean;
};

export type Provider = {
    config?: {
        [key: string]: unknown;
    };
    createdAt: string;
    id: string;
    name: string;
    platform: string;
    updatedAt: string;
};

export type ProvidersListResponseBody = {
    count: number;
    providers: Array<Provider>;
};

export type RegistryExtensions = {
    /**
     * Whether this is the latest version of the server
     */
    isLatest: boolean;
    /**
     * Timestamp when the server was first published to the registry
     */
    publishedAt: string;
    /**
     * Server lifecycle status
     */
    status: 'active' | 'deprecated' | 'deleted';
    /**
     * Timestamp when the server entry was last updated
     */
    updatedAt?: string;
};

export type Repository = {
    /**
     * Repository identifier from the hosting service (e.g., GitHub repo ID). Owned and determined by the source forge. Should remain stable across repository renames and may be used to detect repository resurrection attacks - if a repository is deleted and recreated, the ID should change. For GitHub, use: gh api repos/<owner>/<repo> --jq '.id'
     */
    id?: string;
    /**
     * Repository hosting service identifier. Used by registries to determine validation and API access methods.
     */
    source?: string;
    /**
     * Optional relative path from repository root to the server location within a monorepo or nested package structure. Must be a clean relative path.
     */
    subfolder?: string;
    /**
     * Repository URL for browsing source code. Should support both web browsing and git clone operations.
     */
    url?: string;
};

export type ResourceDeploymentsMeta = {
    count: number;
    deployments: Array<DeploymentSummary>;
};

export type ServerJson = {
    /**
     * JSON Schema URI for this server.json format
     */
    $schema: string;
    /**
     * Extension metadata using reverse DNS namespacing for vendor-specific data
     */
    _meta?: ServerMeta;
    /**
     * Clear human-readable explanation of server functionality.
     */
    description: string;
    /**
     * Optional set of sized icons that the client can display in a user interface.
     */
    icons?: Array<Icon>;
    /**
     * Server name in reverse-DNS format. Must contain exactly one forward slash separating namespace from server name.
     */
    name: string;
    /**
     * Array of package configurations
     */
    packages?: Array<Package>;
    /**
     * Array of remote configurations
     */
    remotes?: Array<Transport>;
    /**
     * Optional repository metadata for the MCP server source code.
     */
    repository?: Repository;
    /**
     * Optional human-readable title or display name for the MCP server.
     */
    title?: string;
    /**
     * Version string for this server. SHOULD follow semantic versioning.
     */
    version: string;
    /**
     * Optional URL to the server's homepage, documentation, or project website.
     */
    websiteUrl?: string;
};

export type ServerListResponse = {
    metadata: ServerMetadata;
    servers: Array<ServerResponse>;
};

export type ServerMeta = {
    /**
     * Publisher-provided metadata for downstream registries
     */
    'io.modelcontextprotocol.registry/publisher-provided'?: {
        [key: string]: unknown;
    };
};

export type ServerMetadata = {
    count: number;
    nextCursor?: string;
};

export type ServerReadmeResponse = {
    content: string;
    contentType: string;
    fetchedAt: string;
    sha256: string;
    sizeBytes: number;
    version: string;
};

export type ServerResponse = {
    _meta: ServerResponseMeta;
    server: ServerJson;
};

export type ServerResponseMeta = {
    'aregistry.ai/deployments'?: ResourceDeploymentsMeta;
    'aregistry.ai/semantic'?: ServerSemanticMeta;
    'io.modelcontextprotocol.registry/official'?: RegistryExtensions;
};

export type ServerSemanticMeta = {
    score: number;
};

export type SignatureTokenExchangeInput = {
    /**
     * Domain name
     */
    domain: string;
    /**
     * Hex-encoded signature of timestamp
     */
    signed_timestamp: string;
    /**
     * RFC3339 timestamp
     */
    timestamp: string;
};

export type SkillJson = {
    category?: string;
    description: string;
    name: string;
    packages?: Array<SkillPackageInfo>;
    remotes?: Array<SkillRemoteInfo>;
    repository?: SkillRepository;
    status?: string;
    title?: string;
    version: string;
    websiteUrl?: string;
};

export type SkillListResponse = {
    metadata: SkillMetadata;
    skills: Array<SkillResponse>;
};

export type SkillMetadata = {
    count: number;
    nextCursor?: string;
};

export type SkillPackageInfo = {
    identifier: string;
    registryType: string;
    transport: SkillPackageInfoTransportStruct;
    version: string;
};

export type SkillPackageInfoTransportStruct = {
    type: string;
};

export type SkillRef = {
    image?: string;
    name: string;
    registrySkillName?: string;
    registrySkillVersion?: string;
    registryURL?: string;
};

export type SkillRegistryExtensions = {
    isLatest: boolean;
    publishedAt: string;
    status: string;
    updatedAt: string;
};

export type SkillRemoteInfo = {
    url: string;
};

export type SkillRepository = {
    source: string;
    url: string;
};

export type SkillResponse = {
    _meta: SkillResponseMeta;
    skill: SkillJson;
};

export type SkillResponseMeta = {
    'io.modelcontextprotocol.registry/official'?: SkillRegistryExtensions;
};

export type TokenResponse = {
    expires_at: number;
    registry_token: string;
};

export type Transport = {
    /**
     * HTTP headers for streamable-http or sse transports
     */
    headers?: Array<KeyValueInput>;
    /**
     * Transport type (stdio, streamable-http, or sse)
     */
    type: string;
    /**
     * URL for streamable-http or sse transports
     */
    url?: string;
};

export type UpdateProviderInput = {
    config?: {
        [key: string]: unknown;
    };
    name?: string;
};

export type VersionBody = {
    /**
     * Build timestamp
     */
    build_time: string;
    /**
     * Git commit SHA
     */
    git_commit: string;
    /**
     * Application version
     */
    version: string;
};

export type ListAgentsV0Data = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Pagination cursor
         */
        cursor?: string;
        /**
         * Number of items per page
         */
        limit?: number;
        /**
         * Filter agents updated since timestamp (RFC3339 datetime)
         */
        updated_since?: string;
        /**
         * Search agents by name (substring match)
         */
        search?: string;
        /**
         * Filter by version ('latest' for latest version, or an exact version like '1.2.3')
         */
        version?: string;
        /**
         * Use semantic search for the search term
         */
        semantic_search?: boolean;
        /**
         * Optional maximum cosine distance when semantic_search is enabled
         */
        semantic_threshold?: number;
    };
    url: '/v0/agents';
};

export type ListAgentsV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type ListAgentsV0Error = ListAgentsV0Errors[keyof ListAgentsV0Errors];

export type ListAgentsV0Responses = {
    /**
     * OK
     */
    200: AgentListResponse;
};

export type ListAgentsV0Response = ListAgentsV0Responses[keyof ListAgentsV0Responses];

export type CreateAgentV0Data = {
    body: AgentJson;
    path?: never;
    query?: never;
    url: '/v0/agents';
};

export type CreateAgentV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type CreateAgentV0Error = CreateAgentV0Errors[keyof CreateAgentV0Errors];

export type CreateAgentV0Responses = {
    /**
     * OK
     */
    200: AgentResponse;
};

export type CreateAgentV0Response = CreateAgentV0Responses[keyof CreateAgentV0Responses];

export type GetAgentVersionsV0Data = {
    body?: never;
    path: {
        /**
         * URL-encoded agent name
         */
        agentName: string;
    };
    query?: never;
    url: '/v0/agents/{agentName}/versions';
};

export type GetAgentVersionsV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type GetAgentVersionsV0Error = GetAgentVersionsV0Errors[keyof GetAgentVersionsV0Errors];

export type GetAgentVersionsV0Responses = {
    /**
     * OK
     */
    200: AgentListResponse;
};

export type GetAgentVersionsV0Response = GetAgentVersionsV0Responses[keyof GetAgentVersionsV0Responses];

export type DeleteAgentVersionV0Data = {
    body?: never;
    path: {
        /**
         * URL-encoded agent name
         */
        agentName: string;
        /**
         * URL-encoded agent version
         */
        version: string;
    };
    query?: never;
    url: '/v0/agents/{agentName}/versions/{version}';
};

export type DeleteAgentVersionV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type DeleteAgentVersionV0Error = DeleteAgentVersionV0Errors[keyof DeleteAgentVersionV0Errors];

export type DeleteAgentVersionV0Responses = {
    /**
     * OK
     */
    200: EmptyResponse;
};

export type DeleteAgentVersionV0Response = DeleteAgentVersionV0Responses[keyof DeleteAgentVersionV0Responses];

export type GetAgentVersionV0Data = {
    body?: never;
    path: {
        /**
         * URL-encoded agent name
         */
        agentName: string;
        /**
         * URL-encoded agent version
         */
        version: string;
    };
    query?: never;
    url: '/v0/agents/{agentName}/versions/{version}';
};

export type GetAgentVersionV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type GetAgentVersionV0Error = GetAgentVersionV0Errors[keyof GetAgentVersionV0Errors];

export type GetAgentVersionV0Responses = {
    /**
     * OK
     */
    200: AgentResponse;
};

export type GetAgentVersionV0Response = GetAgentVersionV0Responses[keyof GetAgentVersionV0Responses];

export type ExchangeDnsTokenV0Data = {
    body: SignatureTokenExchangeInput;
    path?: never;
    query?: never;
    url: '/v0/auth/dns';
};

export type ExchangeDnsTokenV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type ExchangeDnsTokenV0Error = ExchangeDnsTokenV0Errors[keyof ExchangeDnsTokenV0Errors];

export type ExchangeDnsTokenV0Responses = {
    /**
     * OK
     */
    200: TokenResponse;
};

export type ExchangeDnsTokenV0Response = ExchangeDnsTokenV0Responses[keyof ExchangeDnsTokenV0Responses];

export type ExchangeGithubTokenV0Data = {
    body: GitHubTokenExchangeInputBody;
    path?: never;
    query?: never;
    url: '/v0/auth/github-at';
};

export type ExchangeGithubTokenV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type ExchangeGithubTokenV0Error = ExchangeGithubTokenV0Errors[keyof ExchangeGithubTokenV0Errors];

export type ExchangeGithubTokenV0Responses = {
    /**
     * OK
     */
    200: TokenResponse;
};

export type ExchangeGithubTokenV0Response = ExchangeGithubTokenV0Responses[keyof ExchangeGithubTokenV0Responses];

export type ExchangeGithubOidcTokenV0Data = {
    body: GitHubOidcTokenExchangeInputBody;
    path?: never;
    query?: never;
    url: '/v0/auth/github-oidc';
};

export type ExchangeGithubOidcTokenV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type ExchangeGithubOidcTokenV0Error = ExchangeGithubOidcTokenV0Errors[keyof ExchangeGithubOidcTokenV0Errors];

export type ExchangeGithubOidcTokenV0Responses = {
    /**
     * OK
     */
    200: TokenResponse;
};

export type ExchangeGithubOidcTokenV0Response = ExchangeGithubOidcTokenV0Responses[keyof ExchangeGithubOidcTokenV0Responses];

export type ExchangeHttpTokenV0Data = {
    body: SignatureTokenExchangeInput;
    path?: never;
    query?: never;
    url: '/v0/auth/http';
};

export type ExchangeHttpTokenV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type ExchangeHttpTokenV0Error = ExchangeHttpTokenV0Errors[keyof ExchangeHttpTokenV0Errors];

export type ExchangeHttpTokenV0Responses = {
    /**
     * OK
     */
    200: TokenResponse;
};

export type ExchangeHttpTokenV0Response = ExchangeHttpTokenV0Responses[keyof ExchangeHttpTokenV0Responses];

export type ListDeploymentsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by provider platform type (for OSS: local or kubernetes)
         */
        platform?: string;
        /**
         * Filter by provider instance ID
         */
        providerId?: string;
        /**
         * Filter by resource type (mcp, agent)
         */
        resourceType?: 'mcp' | 'agent';
        /**
         * Filter by deployment status
         */
        status?: string;
        /**
         * Filter by deployment origin (managed, discovered)
         */
        origin?: 'managed' | 'discovered';
        /**
         * Case-insensitive substring filter on resource name
         */
        resourceName?: string;
    };
    url: '/v0/deployments';
};

export type ListDeploymentsErrors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type ListDeploymentsError = ListDeploymentsErrors[keyof ListDeploymentsErrors];

export type ListDeploymentsResponses = {
    /**
     * OK
     */
    200: DeploymentsListResponseBody;
};

export type ListDeploymentsResponse = ListDeploymentsResponses[keyof ListDeploymentsResponses];

export type DeployServerData = {
    body: DeploymentRequest;
    path?: never;
    query?: never;
    url: '/v0/deployments';
};

export type DeployServerErrors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type DeployServerError = DeployServerErrors[keyof DeployServerErrors];

export type DeployServerResponses = {
    /**
     * OK
     */
    200: Deployment;
};

export type DeployServerResponse = DeployServerResponses[keyof DeployServerResponses];

export type RemoveDeploymentData = {
    body?: never;
    path: {
        /**
         * Deployment ID
         */
        id: string;
    };
    query?: never;
    url: '/v0/deployments/{id}';
};

export type RemoveDeploymentErrors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type RemoveDeploymentError = RemoveDeploymentErrors[keyof RemoveDeploymentErrors];

export type RemoveDeploymentResponses = {
    /**
     * No Content
     */
    204: void;
};

export type RemoveDeploymentResponse = RemoveDeploymentResponses[keyof RemoveDeploymentResponses];

export type GetDeploymentData = {
    body?: never;
    path: {
        /**
         * Deployment ID
         */
        id: string;
    };
    query?: never;
    url: '/v0/deployments/{id}';
};

export type GetDeploymentErrors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type GetDeploymentError = GetDeploymentErrors[keyof GetDeploymentErrors];

export type GetDeploymentResponses = {
    /**
     * OK
     */
    200: Deployment;
};

export type GetDeploymentResponse = GetDeploymentResponses[keyof GetDeploymentResponses];

export type CancelDeploymentData = {
    body?: never;
    path: {
        /**
         * Deployment ID
         */
        id: string;
    };
    query?: never;
    url: '/v0/deployments/{id}/cancel';
};

export type CancelDeploymentErrors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type CancelDeploymentError = CancelDeploymentErrors[keyof CancelDeploymentErrors];

export type CancelDeploymentResponses = {
    /**
     * No Content
     */
    204: void;
};

export type CancelDeploymentResponse = CancelDeploymentResponses[keyof CancelDeploymentResponses];

export type GetDeploymentLogsData = {
    body?: never;
    path: {
        /**
         * Deployment ID
         */
        id: string;
    };
    query?: never;
    url: '/v0/deployments/{id}/logs';
};

export type GetDeploymentLogsErrors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type GetDeploymentLogsError = GetDeploymentLogsErrors[keyof GetDeploymentLogsErrors];

export type GetDeploymentLogsResponses = {
    /**
     * No Content
     */
    204: void;
};

export type GetDeploymentLogsResponse = GetDeploymentLogsResponses[keyof GetDeploymentLogsResponses];

export type GetHealthV0Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v0/health';
};

export type GetHealthV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type GetHealthV0Error = GetHealthV0Errors[keyof GetHealthV0Errors];

export type GetHealthV0Responses = {
    /**
     * OK
     */
    200: HealthBody;
};

export type GetHealthV0Response = GetHealthV0Responses[keyof GetHealthV0Responses];

export type PingV0Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v0/ping';
};

export type PingV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type PingV0Error = PingV0Errors[keyof PingV0Errors];

export type PingV0Responses = {
    /**
     * OK
     */
    200: PingBody;
};

export type PingV0Response = PingV0Responses[keyof PingV0Responses];

export type ListProvidersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter providers by platform type (local, kubernetes)
         */
        platform?: string;
    };
    url: '/v0/providers';
};

export type ListProvidersErrors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type ListProvidersError = ListProvidersErrors[keyof ListProvidersErrors];

export type ListProvidersResponses = {
    /**
     * OK
     */
    200: ProvidersListResponseBody;
};

export type ListProvidersResponse = ListProvidersResponses[keyof ListProvidersResponses];

export type CreateProviderData = {
    body: CreateProviderInput;
    path?: never;
    query?: never;
    url: '/v0/providers';
};

export type CreateProviderErrors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type CreateProviderError = CreateProviderErrors[keyof CreateProviderErrors];

export type CreateProviderResponses = {
    /**
     * OK
     */
    200: Provider;
};

export type CreateProviderResponse = CreateProviderResponses[keyof CreateProviderResponses];

export type DeleteProviderData = {
    body?: never;
    path: {
        /**
         * Provider ID
         */
        providerId: string;
    };
    query?: {
        /**
         * Provider platform hint (optional)
         */
        platform?: string;
    };
    url: '/v0/providers/{providerId}';
};

export type DeleteProviderErrors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type DeleteProviderError = DeleteProviderErrors[keyof DeleteProviderErrors];

export type DeleteProviderResponses = {
    /**
     * No Content
     */
    204: void;
};

export type DeleteProviderResponse = DeleteProviderResponses[keyof DeleteProviderResponses];

export type GetProviderData = {
    body?: never;
    path: {
        /**
         * Provider ID
         */
        providerId: string;
    };
    query?: {
        /**
         * Provider platform hint (optional)
         */
        platform?: string;
    };
    url: '/v0/providers/{providerId}';
};

export type GetProviderErrors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type GetProviderError = GetProviderErrors[keyof GetProviderErrors];

export type GetProviderResponses = {
    /**
     * OK
     */
    200: Provider;
};

export type GetProviderResponse = GetProviderResponses[keyof GetProviderResponses];

export type UpdateProviderData = {
    body: UpdateProviderInput;
    path: {
        /**
         * Provider ID
         */
        providerId: string;
    };
    query?: {
        /**
         * Provider platform hint (optional)
         */
        platform?: string;
    };
    url: '/v0/providers/{providerId}';
};

export type UpdateProviderErrors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type UpdateProviderError = UpdateProviderErrors[keyof UpdateProviderErrors];

export type UpdateProviderResponses = {
    /**
     * OK
     */
    200: Provider;
};

export type UpdateProviderResponse = UpdateProviderResponses[keyof UpdateProviderResponses];

export type ListServersV0Data = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Pagination cursor
         */
        cursor?: string;
        /**
         * Number of items per page
         */
        limit?: number;
        /**
         * Filter servers updated since timestamp (RFC3339 datetime)
         */
        updated_since?: string;
        /**
         * Search servers by name (substring match)
         */
        search?: string;
        /**
         * Filter by version ('latest' for latest version, or an exact version like '1.2.3')
         */
        version?: string;
        /**
         * Use semantic search for the search term (hybrid with substring filter when search is set)
         */
        semantic_search?: boolean;
        /**
         * Optional maximum distance for semantic matches (cosine distance)
         */
        semantic_threshold?: number;
    };
    url: '/v0/servers';
};

export type ListServersV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type ListServersV0Error = ListServersV0Errors[keyof ListServersV0Errors];

export type ListServersV0Responses = {
    /**
     * OK
     */
    200: ServerListResponse;
};

export type ListServersV0Response = ListServersV0Responses[keyof ListServersV0Responses];

export type CreateServerV0Data = {
    body: ServerJson;
    path?: never;
    query?: never;
    url: '/v0/servers';
};

export type CreateServerV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type CreateServerV0Error = CreateServerV0Errors[keyof CreateServerV0Errors];

export type CreateServerV0Responses = {
    /**
     * OK
     */
    200: ServerResponse;
};

export type CreateServerV0Response = CreateServerV0Responses[keyof CreateServerV0Responses];

export type GetServerReadmeV0Data = {
    body?: never;
    path: {
        /**
         * URL-encoded server name
         */
        serverName: string;
    };
    query?: never;
    url: '/v0/servers/{serverName}/readme';
};

export type GetServerReadmeV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type GetServerReadmeV0Error = GetServerReadmeV0Errors[keyof GetServerReadmeV0Errors];

export type GetServerReadmeV0Responses = {
    /**
     * OK
     */
    200: ServerReadmeResponse;
};

export type GetServerReadmeV0Response = GetServerReadmeV0Responses[keyof GetServerReadmeV0Responses];

export type GetServerVersionsV0Data = {
    body?: never;
    path: {
        /**
         * URL-encoded server name
         */
        serverName: string;
    };
    query?: never;
    url: '/v0/servers/{serverName}/versions';
};

export type GetServerVersionsV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type GetServerVersionsV0Error = GetServerVersionsV0Errors[keyof GetServerVersionsV0Errors];

export type GetServerVersionsV0Responses = {
    /**
     * OK
     */
    200: ServerListResponse;
};

export type GetServerVersionsV0Response = GetServerVersionsV0Responses[keyof GetServerVersionsV0Responses];

export type DeleteServerVersionV0Data = {
    body?: never;
    path: {
        /**
         * URL-encoded server name
         */
        serverName: string;
        /**
         * URL-encoded server version
         */
        version: string;
    };
    query?: {
        /**
         * If true, return all versions of the server instead of a single version
         */
        all?: boolean;
    };
    url: '/v0/servers/{serverName}/versions/{version}';
};

export type DeleteServerVersionV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type DeleteServerVersionV0Error = DeleteServerVersionV0Errors[keyof DeleteServerVersionV0Errors];

export type DeleteServerVersionV0Responses = {
    /**
     * OK
     */
    200: EmptyResponse;
};

export type DeleteServerVersionV0Response = DeleteServerVersionV0Responses[keyof DeleteServerVersionV0Responses];

export type GetServerVersionV0Data = {
    body?: never;
    path: {
        /**
         * URL-encoded server name
         */
        serverName: string;
        /**
         * URL-encoded server version
         */
        version: string;
    };
    query?: {
        /**
         * If true, return all versions of the server instead of a single version
         */
        all?: boolean;
    };
    url: '/v0/servers/{serverName}/versions/{version}';
};

export type GetServerVersionV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type GetServerVersionV0Error = GetServerVersionV0Errors[keyof GetServerVersionV0Errors];

export type GetServerVersionV0Responses = {
    /**
     * OK
     */
    200: ServerListResponse;
};

export type GetServerVersionV0Response = GetServerVersionV0Responses[keyof GetServerVersionV0Responses];

export type EditServerV0Data = {
    body: ServerJson;
    path: {
        /**
         * URL-encoded server name
         */
        serverName: string;
        /**
         * URL-encoded version to edit
         */
        version: string;
    };
    query?: {
        /**
         * New status for the server (active, deprecated, deleted)
         */
        status?: 'active' | 'deprecated' | 'deleted';
    };
    url: '/v0/servers/{serverName}/versions/{version}';
};

export type EditServerV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type EditServerV0Error = EditServerV0Errors[keyof EditServerV0Errors];

export type EditServerV0Responses = {
    /**
     * OK
     */
    200: ServerResponse;
};

export type EditServerV0Response = EditServerV0Responses[keyof EditServerV0Responses];

export type GetServerVersionReadmeV0Data = {
    body?: never;
    path: {
        /**
         * URL-encoded server name
         */
        serverName: string;
        /**
         * URL-encoded server version
         */
        version: string;
    };
    query?: {
        /**
         * If true, return all versions of the server instead of a single version
         */
        all?: boolean;
    };
    url: '/v0/servers/{serverName}/versions/{version}/readme';
};

export type GetServerVersionReadmeV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type GetServerVersionReadmeV0Error = GetServerVersionReadmeV0Errors[keyof GetServerVersionReadmeV0Errors];

export type GetServerVersionReadmeV0Responses = {
    /**
     * OK
     */
    200: ServerReadmeResponse;
};

export type GetServerVersionReadmeV0Response = GetServerVersionReadmeV0Responses[keyof GetServerVersionReadmeV0Responses];

export type ListSkillsV0Data = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Pagination cursor
         */
        cursor?: string;
        /**
         * Number of items per page
         */
        limit?: number;
        /**
         * Filter skills updated since timestamp (RFC3339 datetime)
         */
        updated_since?: string;
        /**
         * Search skills by name (substring match)
         */
        search?: string;
        /**
         * Filter by version ('latest' for latest version, or an exact version like '1.2.3')
         */
        version?: string;
    };
    url: '/v0/skills';
};

export type ListSkillsV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type ListSkillsV0Error = ListSkillsV0Errors[keyof ListSkillsV0Errors];

export type ListSkillsV0Responses = {
    /**
     * OK
     */
    200: SkillListResponse;
};

export type ListSkillsV0Response = ListSkillsV0Responses[keyof ListSkillsV0Responses];

export type CreateSkillV0Data = {
    body: SkillJson;
    path?: never;
    query?: never;
    url: '/v0/skills';
};

export type CreateSkillV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type CreateSkillV0Error = CreateSkillV0Errors[keyof CreateSkillV0Errors];

export type CreateSkillV0Responses = {
    /**
     * OK
     */
    200: SkillResponse;
};

export type CreateSkillV0Response = CreateSkillV0Responses[keyof CreateSkillV0Responses];

export type GetSkillVersionsV0Data = {
    body?: never;
    path: {
        /**
         * URL-encoded skill name
         */
        skillName: string;
    };
    query?: never;
    url: '/v0/skills/{skillName}/versions';
};

export type GetSkillVersionsV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type GetSkillVersionsV0Error = GetSkillVersionsV0Errors[keyof GetSkillVersionsV0Errors];

export type GetSkillVersionsV0Responses = {
    /**
     * OK
     */
    200: SkillListResponse;
};

export type GetSkillVersionsV0Response = GetSkillVersionsV0Responses[keyof GetSkillVersionsV0Responses];

export type GetSkillVersionV0Data = {
    body?: never;
    path: {
        /**
         * URL-encoded skill name
         */
        skillName: string;
        /**
         * URL-encoded skill version
         */
        version: string;
    };
    query?: never;
    url: '/v0/skills/{skillName}/versions/{version}';
};

export type GetSkillVersionV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type GetSkillVersionV0Error = GetSkillVersionV0Errors[keyof GetSkillVersionV0Errors];

export type GetSkillVersionV0Responses = {
    /**
     * OK
     */
    200: SkillResponse;
};

export type GetSkillVersionV0Response = GetSkillVersionV0Responses[keyof GetSkillVersionV0Responses];

export type GetVersionV0Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v0/version';
};

export type GetVersionV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type GetVersionV0Error = GetVersionV0Errors[keyof GetVersionV0Errors];

export type GetVersionV0Responses = {
    /**
     * OK
     */
    200: VersionBody;
};

export type GetVersionV0Response = GetVersionV0Responses[keyof GetVersionV0Responses];
