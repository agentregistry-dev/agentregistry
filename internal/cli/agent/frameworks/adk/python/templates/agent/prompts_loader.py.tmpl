# AUTOGENERATED FILE: DO NOT EDIT
# Generated by the AgentRegistry CLI.

import json
import os
from pathlib import Path
from typing import Dict, List, Optional


def _load_prompts() -> List[dict]:
    """Load prompts from prompts.json.

    The agent config directory is mounted to /config in Docker, so the file
    is found at /config/prompts.json. For local development, it also checks
    next to this Python module.
    """
    config_paths = [
        Path(__file__).parent / "prompts.json",
        Path("/config/prompts.json"),
    ]

    env_path = os.environ.get("PROMPTS_CONFIG_PATH")
    if env_path:
        config_paths.insert(0, Path(env_path))

    for config_path in config_paths:
        if not config_path.exists():
            continue
        try:
            with open(config_path, "r") as f:
                data = json.load(f)
                if isinstance(data, list):
                    return data
        except (json.JSONDecodeError, IOError):
            continue

    return []


_cached_prompts: Optional[Dict[str, str]] = None


def _get_prompt_map() -> Dict[str, str]:
    """Return a name -> content mapping of all prompts."""
    global _cached_prompts
    if _cached_prompts is None:
        _cached_prompts = {}
        for p in _load_prompts():
            name = p.get("name", "")
            content = p.get("content", "")
            if name:
                _cached_prompts[name] = content
    return _cached_prompts


def get_prompt_names() -> List[str]:
    """Return the names of all available prompts."""
    return list(_get_prompt_map().keys())


def get_prompt(name: str) -> Optional[str]:
    """Get a prompt's text content by name.

    Returns the prompt text if found, None otherwise.
    """
    return _get_prompt_map().get(name)


def build_instruction(default_instruction: str) -> str:
    """Build the agent instruction from registry prompts.

    If prompts.json contains resolved prompts, their content is concatenated
    (separated by blank lines). Otherwise the provided default instruction is used.
    """
    names = get_prompt_names()
    if not names:
        return default_instruction

    parts = []
    for name in names:
        content = get_prompt(name)
        if content:
            parts.append(content)
    return "\n\n".join(parts) if parts else default_instruction
